[ 파일 만들기 ]
    1. [src]폴더 오른쪽 클릭
    2. [새로만들기]
        1. java 클래스
        2. 파일 ( 파일명.txt )
        3. 패키지 ( 폴더 )

[ 자바 클래스 파일 생성 ]
    1. [src]폴더 오른쪽 클릭
    2. [새로만들기] -> [ 패키지 ] -> (강의기준 day01~ )
    3. [특정폴더] 오른쪽 클릭 -> [ 새로만들기 ] -> [java클래스]
        * 클래스 파일 명은 첫글자를 무조건 대문자로 시작.
        예) Example1

[ 자바 구동 원리 ]
    1. [코딩] 개발자는 .java 파일내 자바 문법 작성한다.
    - Example1.java ( 파일 )
    2. [실행] .java 파일 -- 컴파일(번역/해석) ---> .class 파일(바이트) 생성
    3. [처리] (컴퓨터가) .class 파일 처리한다.

[ 주석 ]
    HTML : <!-- 주석처리 -->
    CSS : /* 주석처리 */
    JS/JAVA :   // 한줄주석
                /*  여러줄주석 */

[ 자바 활용처 ]
    1. 소프트웨어 : javafx툴 활용, 등등
    2. 웹 : JSP , Spring 등등
    3. 앱 : 안드로이드 등등

[ 자바 코드 실행 ]
    - 자바는 클래스 단위로 컴파일 되고 , 컴파일된 코드는 main함수 부터 읽어서(스레드) 처리한다.

[ 리터럴 ]
    - 3 , 3.14 , 'a' , "ABC" , true 등등
    1. 정의 : 키보드 로 부터 입력한 자료
    2. 종류
        정수(int) , 실수(double) , 문자('') , 문자열("") , 논리(boolean)

[ 기본타입 ]
    1. 정의 : 자료들의 분류
    2. 목적 : 효율적인 자료 처리 (*분리수거)
    3. 종류(8가지)
        [정수]       byte        1바이트        -128 ~ 127
                    short       2바이트        +-3만정도 까지
                    int         4바이트        +-21억정도 까지 (*리터럴정수)
                    long        8바이트        +-21억정도 이상 , 리터럴정수 뒤에 L/l 붙이기
        [실수]       float       4바이트        소수점8자리 표현 , 리터럴실수 뒤에 F/f 붙이기
                    double      8바이트        소수점17자리 표현(*리터럴실수)
        [논리]       boolean     1바이트        true/false
        [문자]       char        2바이트        유니코드 , ' '작은따옴표 감싼 문자1개
                    *String      클래스         클래스 , " " 큰따옴표 감싼 문자여러개
[출력함수]
    1. System.out.print();                                      : 출력
    2. System.out.println();                                    : 출력후 줄바꿈
    3. System.out.printf( "형식문자1 형식문자2" , 값1 , 값2 );    : 서식(형식) 맞춤 출력
        - 형식문자 : %s 문자열 , %d 정수 , %c 문자 , %f 실수
        - 자릿수 :
            %자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 공백 , 오른쪽 정렬
            %-자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 공백 , 왼쪽 정렬
            %0자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 0채움
        - 소수점 자릿수 :
            %전체자릿수.소수점자릿수f : (소수점포함)전체 자릿수 만큼 자릿수 차지

[ 이스케이프/제어 문자 ] : 특수문자에 기능이 포함
    \n 줄바꿈 , \t 들여쓰기 , \\ 백슬래시 출력 , \' 작은따옴표 출력 , \" 큰따옴표 출력

[ (변수)타입변환 ]
    1. 자동(묵시적) 타입변환
        (1) byte -> short/char -> int -> long -> float -> double
        (2) 메모리 크기가 작은 것 에서 큰 것으로 변환 가능.
        (3) 연산결과
            - 두 항 중에 더 큰 항의 타입으로 결과 반환
            - 단) int 이하는 무조건 int 반환

    2. 강제(명시적) 타입 변환
        (1) double -> float -> long -> int -> short/char -> byte
        (2) 메모리 크기가 큰 것 부터 작은 것으로 변환 가능!
        (3) ( 변환형타임명 )변수명;
        (4) !! 자료 손실이 있을 수도 있다.

[ 입력함수 ]
    1. 콘솔 화면에서 키보드로 부터 입력받는 방법
    2. 사용법
        (1) 입력 객체 생성 : new Scanner( System.in );
            Scanner scan = new Scanner( System.in );
            * 주의할 점 : Scanner 입력시 자동완성 권장. 안할 경우 : 클래스 위에 import java.util.Scanner; 직접 쳐준다.
            * import란 다른 클래스(코드 정보) 호출

        (2) 입력함수
        .next()                 : 입력받은 자료를 문자열(String)으로 반환, 띄어쓰기 불가능
        .nextLine()             : 입력받은 자료를 문자열(String)으로 반환, 띄어쓰기 가능, 문제점 : 앞에 다른 next() 존재할 경우, 의미없는 nextLine() 하나 필요함.
        .nextByte()             : 입력받은 자료를 정수(Byte)로 반환을 한다.
        .nextShort()            : 입력받은 자료를 정수(Short)로 반환을 한다.
        .nextInt()              : 입력받은 자료를 정수(Int)로 반환을 한다.
        .nextLong()             : 입력받은 자료를 정수(Long)로 반환을 한다.
        .nextFloat()            : 입력받은 자료를 실수(Float)로 반환을 한다.
        .nextDouble()           : 입력받은 자료를 실수Double()로 반환을 한다.
        .nextBoolean()          : 입력받은 자료를 논리(Boolean)로 반환을 한다.
        .next().charAt(0)       : 입력받은 자료를 첫글자 문자(Char) 1개 반환을 한다.

[ 연산자 ]

    1. 산술연산자    : + 더하기 - 빼기 * 곱하기 / 나누기 % 나머지
    2. 연결연산자    : +연결
    3. 비교연산자    : >초과 >= 이상 < 미만 <= 이하 == 같다 != 같지않다
    4. 논리연산자    : && 이면서 || 이거나 !부정
    5. 증감연산자    : ++변수명 변수명++ --변수명 변수명--
    6. 복합대입연산자 : =대입 +=더한 후 대입 *=, -=, /=, %= 모든 건 다 연산 후 대입
    7. 삼항연산자    : 조건 ? 참 : 거짓 , 중첩가능
    8. 문자열비교    : 문자열 "문자열A".equals("문자열B")

[ 조건문 ]
    1. 조건에 따른 결과(true/false)의 코드 흐름 제어 ,
    2. 종류)
        (1) if( 조건문 ) 참일때명령어;
        (2) if( 조건문 ){ 참일때명령어1; 참일때명렁어2; }
        (3) if( 조건문 ){ 참일때명령어; }
            else{ 거짓일때명령어; }
        (4) if( 조건문1 ) { 참1일떄명령어;}
            else if( 조건문2 ) { 참2일때명령어; }
            else if( 조건문3 ) { 참3일때명령어; }
            else{ 거짓일때명령어; }
        (5) if( 조건문1 ) { 참1일때명령어; }
            if( 조건문2 ) { 참2일때명령어; }
            if( 조건문3 ) { 참3일때명렁어; }
        (6) if( 조건문1 ) {
                if( 조건문2 ){ }
                else{ }
            }else{ }
[ 배열 ]
    1. 정의 : *동일한* 자료형(타입)의 여러개 자료들을 순서대로 저장하는 자료의 타입
    2. 특징
        1) 동일한 타입 : 서로 다른 자료형(타입) 데이터는 같은 배열에 저장 불가능
        2) *고정 길이* : 배열은 한 번 선언(생성)되면 길이/크기/요소 개수 수정 할 수 없음. < 요소 추가/삭제 없다. >
        3) 요소 기본값 : 배열내 요소의 초기값이 없으면 자동으로 기본값
            - 정수 : 0 , 실수 : 0.0 , 논리 : false , 객체 : null
        4) 인덱스 : 배열내 저장된 요소들의 순서번호 , 0번 시작
    3. 사용법
        1) 선언/생성
            (방법1) new 타입[길이];     , int[] 변수명 = new int[3];
            (방법2) { 값1, 값2, 값3 }  , double[] 변수명 = { 3.14, 5.1, 78.62 }
        2) 호출
            (1) 변수명                         , 배열의 주소값 반환
            (2) Arrays.toString( 변수명 );     , 배열내 요소 값들을 문자열로 반환
            (3) 변수명[인덱스]                  , 배열내 특정한 요소 값 반환
            (4) 변수명.length                  , 배열내 요소 개수 반환
        3) 요소 추가/삭제 없음.
        4) 배열과 반복문
            (1) 일반 for문 : 인덱스가 있는 배열내 요소값들을 하나씩 순회
                for( int index = 0 ; index <= 배열변수명.length - 1 ; index++ ){
                    타입 반복변수명 = 배열변수명[index];
                }
            (2) 향상된 for문 : 인덱스 없이 배열내 요소값들을 하나씩 순회
                for( 타입 반복변수명 : 배열변수명 ){

                }


[ 클래스와 객체 ]
    * 자바는 컴파일(번역)을 클래스 단위로 처리한다.
    1) 정의
        (1) 정의     : '주체'가 아닌 의사나 행위르르 미치는 대상
        (2) 클래스    : '객체'를 만들기 위한 객체를 정의하는 *설계도*
    2) 클래스 멤버
        (1) 멤버변수    : 객체내 포함할 변수 , 속성/특징/성질     =   값/데이터
        (2) 메소드     : 객체내 포함할 함수 , 이벤트/행위/작동    =   실행명령어집합
        (3) 생성자     : 객체가 생성될 때 초기화함수 , 초기화
    3) 클래스 사용법
        1) 선언하는 방법  : 1. .java 파일내 여러개 클래스 존재 [ 비권장 ] 2. .java파일내 클래스는 1개 존재 [ 권장 ]
            class 클래스명{
                멤버변수;
                메소드;
                생성자;
            }
    4) 객체 사용법
        (1) 객체 선언하는 방법
            new 클래스명();     , 주로 변수명 = new 클래스명();
            * new 연산자 : 클래스 기반으로 객체를 생성하며 메모리 1개를 할당하는 키워드
        (2) 객체 내 멤벼변수 호출
            변수명.멤버변수명
            * . 접근연산자 : 객체내 포함된 멤버변수 , 메소드 등 접근하는 키워드
        (3) 객체내 멤버변수 값 수정
            변수명.멤버변수명 = 새로운 값;
        (4) 객체내 멤버변수 추가/삭제 불가능 : 클래스는 컴파일(실행/변역)된 이후에 추가/수정 불가능

[ 메소드 ]
    1. 정의 : 하나의 기능을 수행하는 일련의 명령어/코드 들
        ** 속성 = 값/데이터 저장 ** VS 함수 = 코드/명령어 저장

    2. 용어 :
        1) 인수/인자 값      : 메소드 호출시 메소드에게 전달되는 값
            예) 변수명.메소드명( 인수값1 , 인수값2 ) ;

        2) 매개변수 값       : 메소드 실행될 때 메소드 인수/인자 값을 대입 받는 변수   *지역변수 특징
            예) void 메소드명 ( 타입 매개변수1 , 타입 매개변수 2 );
            -> 주의할 점 : 1. 인자값 과 매개변수의 타입은 일치해야한다 !!
                         2. 매개변수는 없을 수도 있다.
                         3. 매개변수는 지역변수라서 메소드가 끝나면 사라진다.

        3) 반환 값 (return)  : 메소드가 종료될 때 메소드를 호출했던 곳으로 되돌려주는 값
            예) return 반환값;

        4) 반환 타입         : 반환 값의 자료형/타입
            예) 반환타입 메소드명() {}
            -> 주의할 점 : 1. 반환값과 반환타입은 일치해야한다 !!
                          2. 반환값은 항상 자료 하나만 가능하다.
                          3. 반환값이 없을 때는 void 라는 타입의 키워드 사용한다.
    3. 사용법
        1) 정의/만들기
            반환타입 메소드명 ( 타입 매개변수1 , 타입 매개변수2,,,,,,, 등등 ){
                원하는 실행코드;
                return 반환값;
            }

        2) 호출/사용하기 ( 6 ~ 7가지 )
            방법1) 호출하고자 하는 메소드가 다른 클래스 일때
                (1) 클래스명 변수명 = new 클래스명();
                (2) 객체를 통해 메소드를 호출 : 변수명.메소드명( 인수값1 , 인수값2 ,,,,, 등등 );
            방법2) 호출하고자 하는 메소드가 다른 클래스 일때
                (1) 메소드명( 인수값1, 인수값2 );

[ 생성자 ]
    1. 정의 : 객체(인스턴스)를 생성(new) 할때 사용되는 초기화 메소드
    2. 규칙
        1) 클래스명과 생성자명은 동일하다.
        2) 오버로드 : 매개변수의 개수/타입/순서 가 다르면 동일한 이름으로 여러개 선언
    3. 종류
        1) 기본생성자 : 매개변수 없는 생성자
            - 클래스내 생성자가 하나도 존재 하지 않으면 컴파일(실행)될때 자동 생성
        2) 생성자 : 주로 매개변수 있는 생성자
            - 메소드와 다르게 반환타입/값 없다.
    4. 목적 : 객체 생성시 멤버변수에 빠른 초기화 혹은 유효성 검사( 규칙적인 초기화 )
    5. 사용법
        1) 선언/정의 방법
            class 클래스명{
                생성자명( ){ }
            }
        2) 호출/사용 방법
            new 생성자명();

