package inheritance_by_yeonwoo;
/* 
    ! 신연우만의 상속에 대한 총정리 !

    A 클래스 그리고 A 클래스를 상속받는 B 클래스가 있다고 가정

    1. 멤버변수는 고유의 필드값

        A 클래스에 멤버변수가 String name 이고
        B 클래스에 멤버변수가 int age 이면
        A a = new B(); 했을 때
        아래와 같이 된다.
        ┌─ A 가 선언한 필드 ───┐   ← name
        │  String name       │
        ├─ B 가 선언한 필드 ───┤   ← age
        │  int    age        │
        └────────────────────┘   (B 객체 안에)

        A a = new B(); 일때
        멤버변수와 생성자는 오버라이딩이 안되기 때문에
        B 클래스 멤버변수에 String name; 이라는 똑같은 값이 선언이 되어있어도 a.name을 해도 A 클래스에 있는 String name;의 값이 들어간다

        그리고 B 클래스에 있는 String name은 필드 숨김(hiding)처리 돼서 쓸 수 없다. (필드는 오버라이딩 불가)

        ** B에 있는 name을 쓰려면 ! 강제타입변환 ! 후 써야한다.

        위 그림과 같이 A에는 name이 있고 B에는 age가 있는데 B 메소드에서 name을 수정해도 A 클래스의 name이 들어간다. 한 필드 안에서 공유하기 때문
        그리고 B 클래스에서 name이 없을 시 B 클래스 내에서 name 값을 수정하면 A 클래스의 name 값이 수정된다. B 클래스 내에 name 이 있을 시 B 클래스 name이 수정되지만 숨김 처리 돼서 쓸 수 없다.
        A 클래스 내에 age가 없는데 a.age 자체를 호출한다면 그건 쓸 수 없다.  !! 예시 3 참고 !!

    =========================================

    2. 생성자 역시 오버라이딩 불가

        생성자는 A 클래스 B 클래스를 나눠서 설명가능한데,   A a = new B();일 때
        A 클래스 내에서 생성자를 선언하지 않았다면 자동 생성자 A(){}가 들어갈 것.
        B 클래스 내에서도 생성자를 선언 하지 않았다면 자동 생성자 B(){}가 들어간다.

        근데 생성자는 오버라이딩이 불가능하기 때문에 B를 객체로 준 후 호출하면 자동 super();가 들어가진다. 고로 A(){}에 super() 빈값이 들어가져 정상 컴파일 된다.
        * 여기서 super란? 자식 클래스에서 부모클래스를 가르키는 키워드이다.*

        만약 A 생성자에 A(int a){} 라는 것이 들어갔다고 가정하자. B 생성자에서 해당 A 생성자에게 주는 값이 없을 시 A(int a){} 중 int a에게 주는 값이 없기 때문에 오류가 뜬다.
        그 이유는 B 클래스가 컴파일 되기 전에 A 클래스가 먼저 컴파일 되는데 생성자에 매개변수를 준 이상 A 클래스에 매개변수를 넣어줘야 정상 컴파일 되는 것.
        ( A 클래스가 정상 컴파일 되지 않았는데 B가 정상 컴파일 되는게 더 신기할 나름 ) 결론은 뭐냐? B 생성자에 A 생성자에 넣어줄 값을 넣어줘야함 무조건!!!!!

        그래서 결론은 뭐다? B () { super("1"); } 같은 값을 무조건 넣어줘야 한다. super("1")는 A(int a){} 중 (int a : 매개변수)에게 1을 넣어준다는 뜻이다. !! 아래 1번 예시 참고 !!
        super() 여기 괄호 안에는 변수를 넣어줘도 된다. 근데 같은 필드에 있는 A 클래스의 멤버변수는 줄 수 없다. 생성자가 먼저 컴파일 되기 때문이다.
        결론 !! 변수를 주려면 B 생성자 안에서 해결을 해야한다.

    3. 메소드는 오버라이딩이 가능!

        A a = new B();일 때
        메소드는 A B가 동일 메소드를 가지고 있어야 오버라이딩을 해준다. 이유는 오버라이딩된 메서드를 부를 때는 객체의 실제 타입이 결정권을 가진다.
        B 클래스만 가지고 있다면 오버라이딩이 안되고 오류가 뜸. 왜냐면 타입 자체는 A 클래스이기 때문인데. A 클래스에 없는 메소드를 어떻게 쓴다는지 이해 시키는게 더 어렵다.
        A 클래스만 가지고 있다면 A 메소드가 실행이 된다. 오버라이딩이 될 수 없다. B에 메소드가 없어서 이다.
        super.메소드명 으로 부모 타입의 메소드를 실행시키는 것은 가능하다.   !! 아래 2번 예시 참고 !!

        !!!!!!!!! 오버라이딩 할 때 매개변수랑 리턴값 타입이 같아야 한다. 매개변수가 다르다면 오버로딩이지 오버라이딩이 아니다 !!!!!!!!!!!!

 */
public class inheritance {
    public static void main(String[] args) {
        A a = new B("홍길동",112);
        a.print();
        //  System.out.println(a.age); --> 불가능 //  예시 3번

        B b = new B("홍길동" , 1);
    }
}
class A {
    // 멤버변수
    public String name;
    A(String name){
        this.name = name;
        System.out.println("A 클래스 생성");
    }
    // 메소드
    public void print() {
        System.out.println(name);
    }
}

class B extends A{
    // 멤버변수
    public int age;

    // 생성자
    B(String name ,int age){
        super(name);   // 1번 예시
        this.age = age;
        System.out.println("B 클래스 생성");
    }

    // 메소드
    public void print() {
        super.print();          // 2번 예시
        System.out.println(age);
    }
}
